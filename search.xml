<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[随笔]]></title>
    <url>%2F2019%2F03%2F09%2F%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[人的一切痛苦，本质上都是对自己无能的愤怒 王小波 * 想你的时候，把你的名字写在手心，摊开是思念，握紧是牵挂。 * 想你的时候，把你的容颜画在纸上，想你是快乐，念你是幸福。 * 我想你，在城市的那一头，我想你，在我思念的那一头，你可记得答应过我， * 不管在哪里，都必须要过得很好，每一天都是快乐]]></content>
      <categories>
        <category>心情</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>文艺</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis]]></title>
    <url>%2F2018%2F07%2F13%2FMybatis%2F</url>
    <content type="text"><![CDATA[Mybatis Mybatis是用java编写的持久层框架，底层封装操作数据库的细节，采用ORM(Object Relational Mappging 对象关系映射)使得数据库表中记录与javaBean属性对应:- 实体类中的属性和数据库表的字段名称保持一致 - 通过配置标签&lt;resultMap&gt;将javaBean属性名称和字段名称建立对应关系 在Mybatis中持久层的接口名称和映射文件也叫做：Mapper mybatis的映射配置文件位置和Dao接口的包结构相同，方便使用指定Dao接口包加载时扫描到映射配置文件 执行的是增删改的操作必须要commit 使用连接池可以节省创建连接的时间，以空间成本换取时间成本，提高效率；mybatis使用自定义的连接池POOLED UNPOOLED JNDI均是DataSource接口的实现 UNPOOLED没有使用连接池的思想 而是每次创建一个新的连接 POOLED使用连接池的思想 一次性使用UNPOOLED创建多个连接缓存起来 表和表之间的关系：一对一 一对多 (多对一) 多对多 在Mybatis中将上面的四种关系给简化成两种 一对一: 从表实体应该包含一个主表实体的对象引用 一对一映射配置文件：使用&lt;association&gt;标签 property:javaBean中属性名称 ofType集合元素的数据类型 一对多: 主表实体应该包含从表实体的集合引用 一对多映射配置文件：使用&lt;collection&gt;标签 property:javaBean中属性名称 javaType元素属性的数据类型 事务:为了完成某个业务需要执行一组(多个)SQL操作 这一组SQL操作要么同时成功 要么同时失败 注意：同一个事务中的多个操作必须保证使用的是同一个连接 事务的四个特性：ACID是原子性（atomicity）、一致性（consistency）、隔离性 （isolation）和持久性（durability） 原子性:事务包含的所有操作要么全部成功提交，要么全部失败回滚 一致性: 事务执行前后数据库状态必须处于一致性状态 隔离性:多个用户并发访问数据库时，多个并发事务之间要相互隔离 持久性:事务一旦提交其对数据库中数据的改变就是永久性的 不考虑事务的隔离级别会造成的影响: 脏读;一个事务在处理过程中读取了另一个事务中未提交的数据 不可重复读:对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值.这是因为在查询间隔被另一个事务修改并提交了 虚读(幻读):事务非独立执行时，读取了另一条已经提交的事务 幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数） 事务的隔离级别:设置数据库的隔离级别一定要是在开启事务之前且隔离级别的设置只对当前链接有效 对于使用MySQL命令窗口而言，一个窗口就相当于一个链接，当前窗口设置的隔离级别只对当前窗口中的事务有效 对于JDBC操作数据库来说，一个Connection对象相当于一个链接，而对于Connection对象设置的隔离级别只对该Connection对象有效，与其他链接Connection对象无关。 MySQL数据库为我们提供的四种隔离级别： Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。 Repeatable read (可重复读)：可避免脏读、不可重复读的发生。MySQL的默认隔离级别 Read committed (读已提交)：可避免脏读的发生。 Read uncommitted (读未提交)：最低级别，任何情况都无法保证。 Oracle数据库中，只支持Serializable (串行化)级别和Read committed (读已提交)这两种级别，其中默认的为Read committed级别。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring]]></title>
    <url>%2F2018%2F07%2F13%2FSpring%2F</url>
    <content type="text"><![CDATA[Spring IOC:降低程序间硬编码的过度耦合，管理对象之间的依赖关系，使用反射创建实例对象 创建bean的三种方式 默认调用类中的无参构造方法 spring 管理静态工厂-使用静态工厂的方法创建对象存入容器 spring 管理实例工厂-使用实例工厂的方法创建对象存入容器 bean标签: id(name)：容器中唯一标识 name的命名规范较id比较松散 若均未定义Spring将使用”全限定类名#N”作为 bean的名称标识 class：指定类的全限定类名反射创建对象,默认情况下调用无参构造函数 scope：指定对象的作用范围 singleton :默认值，单例的 prototype :多例的 request :WEB项目中,Spring创建一个Bean的对象,将对象存入到request域中 session :WEB项目中,Spring创建一个Bean的对象,将对象存入到session域中 global session :WEB项目中,应用在集群环境.如果没有集群环境那么globalSession相当于session. init-method：指定类中初始化方法名称。 destroy-method：指定类中销毁方法名称。 Bean生命周期 单例对象：scope=&quot;singleton&quot; 一个应用只有一个对象的实例。它的作用范围就是整个引用 生命周期：&lt;容器状态一致&gt; 多例对象：scope=&quot;prototype&quot; 每次访问对象时，都会重新创建对象实例 生命周期:&lt;对象状态一致&gt; DI:实例化对象时给对象属性赋值三种注入方式: 赋值标识位置: index:参数在构造函数参数列表的索引位置 type:参数在构造函数中的数据类型 name:参数在构造函数中的名称 赋值动作:SPEl表达式 value:基本数据类型和String赋值 ref:bean类型赋值 1.构造函数注入:类中需要提供一个对应参数列表的构造函数，获取bean时必须初始化实例对象 2.set注入:类中需要提供注入成员的set方法，获取bean时只需提供必需初始化属性 p名称空间注入(本质调用类中set方法实现注入功能):在xml中导入p名称空间约束，使用p:propertyName来注入数据 注入集合属性(本质为set注入):注入集合数据在注入集合数据时，只要结构相同，标签可以互换 123456789&lt;property&gt; List 结构中的标签 array &gt;&gt;value list set Map 结构中的标签 map &gt;&gt; entry &gt;&gt; key --&gt;value props &gt;&gt; prop &gt;&gt; key&lt;/property&gt; 3.注解注入 加载核心容器： BeanFactory 和ApplicationContext 的区别：* ApplicationContext：只要一读取配置文件，默认情况下就会创建对象 * BeanFactory：spring容器的顶层接口，什么使用什么时候创建对象 三种配置文件加载方式: ClassPathXmlApplicationContext： 从类的根路径下加载配置文件 推荐使用这种 FileSystemXmlApplicationContext： 从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置 AnnotationConfigApplicationContext: 使用注解配置容器对象使用此类读取注解创建spring容器 IOC注解分类 创建对象注入bean: @Component(value=””): 将当前类对象存入spring容器中，默认id为当前类名的首字母小写 spring支持java依赖注入规范中所提供的@Named注解作为@Component的替代方案 Spring提供的用于明确标识三层架构使用的注解等同于@Component(可任意写) @Controller:表现层 @Service:业务层 @Repository:持久层 XMl配置中指明spring在创建容器时要扫描的包 &lt;context:component-scan base-package=”springIOC”/&gt; 注入数据: @Autowired: 容器中存在唯一匹配的bean对象类型时自动按照类型注入，需提供set方法，注入属性可不提供 spring支持java依赖注入规范中所提供的@Inject注解作为@Autowired的替代方案 @Qualifier(value=””):按类型注入基础上再按照变量名注入 类成员注入时需要和@Autowired同时使用，注入方法参数可单独使用 @Resource(name=””):直接按照bean名称注入 以上三种只能注入其他bean类型数据，基本数据类型和String类型无法使用上述注解注入，且集合类型只能通过XML配置注入 @Value(value=””):注入基本数据类型和String类型，可使用SpEL(Spring Expression Language)表达式 ${表达式}:引用外部参数对应的property,字符串的拼接 #{表达式}:可引用bean对象属性,SpEL表达式 作用范围: @Scope(value=””):指定bean的作用范围:singleton prototype request session global-session 生命周期: PreDestroy:初始化方法 PostConstruct:销毁方法 @Configuration:指定当前类为spring配置类，创建容器时会从该类上加载注解 当配置类作为创建Context对象参数时可省略 @ComponentScan(value/basePackages=”” ):指明初始化容器时扫描包,默认扫描与配置类相同的包 @ComponentScan(basePackageClasses = AccountDao.class)若basePackageClasses中包含类，这些类所在的包将会作为组件扫描的基础包 @Bean(name =””):注入当前对象到容器中，只能注明在方法上，若方法带参需保证容器中存在对应类型的bean @Import(.class):导入其他配置类的字节码 @propertySource(value=”classpath:”):引入外部properties文件配置 spring 整合junit进行单元测试(版本spring 5.x + junit 4.12+) @RunWith(SpringJUnit4ClassRunner.class): @ContextConfiguration()指明生成bean容器的方式: XML配置 location=”classpath:” 注解配置 classes=.class 动态代理: 基于接口的动态代理:Proxy 被代理类最少实现一个接口 newProxyInstance方法的参数： ClassLoader：类加载器 它是用于加载代理对象字节码的。和被代理对象使用相同的类加载器。固定写法。 Class[]：字节码数组 它是用于让代理对象和被代理对象有相同方法。固定写法。 InvocationHandler：用于提供增强的代码 通常情况下都是匿名内部类，但不是必须的 invoke方法的参数: 执行代理对象的任何接口方法都会经过该方法 proxy 代理对象的引用 method 当前执行的方法 Object[] args 当前执行方法所需的参数 基于子类的动态代理:Cglib 被代理类不能是最终类(即不能被final修饰) create方法的参数： Class：它是用于指定被代理对象的字节码 MethodInterceptor：用于提供增强的代码 它是让我们写如何代理。我们一般都是些一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的 invoke方法的参数: 执行代理对象的任何接口方法都会经过该方法 object o : 代理对象的引用 method : 当前执行的方法 Object[] args : 当前执行方法所需的参数 methodProxy ：当前执行方法的代理对象 AOP:面向切面编程 连接点JoinPoint:被拦截到的点spring中这些点指的是方法,因为spring只支持方法类型的连接点 切入点Pointcut:对JoinPoint进行拦截的定义 通知Advice:拦截到JoinPoint之后所要做的事情 切面Aspect:切入点和通知（引介）的结合 织入Weaving:把增强应用到目标对象来创建新的代理对象的过程。 spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入 目标对象Target Object:代理的目标对象。 AOP代理AOP Proxy:类被AOP织入增强后产生的结果代理类。 引介Introduction:在不修改类代码的前提下在运行期为类动态地添加一些方法或属性 通知类型: 前置通知（Before advice） 在某连接点之前执行的通知，但这个通知不能阻止连接点之前的执行流程（除非它抛出一个异常）。 后置通知（After returning advice） 在某连接点正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回 异常通知（After throwing advice） 在方法抛出异常退出时执行的通知。 最终通知（After (finally) advice） 当某连接点退出的时候执行的通知（不论是正常返回还是异常退出） 环绕通知（Around Advice） 包围一个连接点的通知可以在方法调用前后完成自定义的行为其会选择是否继续执行连接点或直接返回它自己的返回值或抛出异常来结束执行。 基于@Aspect注解实现spring AOP的注解开发: @Aspect 表示当前类是一个切面类 @Pointcut(“execution( com.lemon.service.impl..*(..))”) 定义切入点表达式 private void pointCut() {} @Before(“execution( com.lemon.service.impl..*(..))”) 前置通知 @Before(“pointCut()”) 前置通知 @AfterReturning(“pointCut()”) 后置通知 @AfterThrowing(“pointCut()”) 异常通知 @After(“pointCut()”) 最终通知 @Around(“pointCut()”) 环绕通知 @EnableAspectJAutoProxy 配置spring开启注解AOP的支持 事务控制 PlatformTransactionManager是spring的事务管理器接口，实际开发中都是使用它的实现类 org.springframework.jdbc.datasource.DataSourceTransactionManager 使用Spring JDBC或iBatis 进行持久化数据时使用 org.springframework.orm.hibernate5.HibernateTransactionManager 使用Hibernate版本进行持久化数据时使用 TransactionDefinition:事务的定义信息对象，里面有如下方法： getName():获取事务对象名称 getIsolationLevel():获取事务隔离级别 反映事务提交并发访问时的处理态度 isolation_default:默认级别 isolation_read_uncommitted:可读取未提交数据 isolation_read_committed:只能读取已提交数据，Oracle默认级别 isolation_repeatable_read:是否读取其他事务提交修改后的数据 Mysql默认级别 isolation_serializable:是否读取其他事务提交添加后的数据 getPropagationBehavior():获取事务传播行为 REQUIRED:如果当前没有事务，就新建一个事务，如果已经存在一个事务中则加入到这个事务中 （默认值） SUPPORTS:支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务） MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常 REQUERS_NEW:新建事务，如果当前在事务中，把当前事务挂起 NOT_SUPPORTED:以非事务方式执行操作，如果当前存在事务，就把当前事务挂起 NEVER:以非事务方式运行，如果当前存在事务，抛出异常 NESTED:如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行REQUIRED类似的操作 getTimeout():获取事务超时时间 默认值是-1，没有超时限制 若有则以秒为单位进行设置 isReadOnly():获取事务是否只读 建议查询时设置为只读 TransactionStatus 此接口提供的是事务具体的运行状态 flush():刷新事务 hasSavepoint():获取事务是否存在存储点 isCompleted():获取事务是否完成 isNewTransaction():获取事务是否为新事务 isRollbackOnly():获取事务是否回滚 setRollbackOnly():设置事务回滚 事务控制注解支持 @Transactional 事务支持 优先级：方法&gt;类&gt;接口 @EnableTransactionManagement 配置事务通知]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
</search>
